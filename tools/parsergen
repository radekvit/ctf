#!/bin/bash
set -o errexit -o pipefail -o noclobber -o nounset

! getopt --test > /dev/null 
if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
    echo 'I’m sorry, `getopt --test` failed in this environment.'
    exit 999
fi

OPTIONS=o:f:p:c:h
LONGOPTS=output:,folder:,parser:,ctf:,help,cxx:

# -use ! and PIPESTATUS to get exit code with errexit set
# -temporarily store output to be able to check for errors
# -activate quoting/enhanced mode (e.g. by writing out “--options”)
# -pass arguments only via   -- "$@"   to separate them correctly
! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name "$0" -- "$@")
if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    # e.g. return value is 1
    #  then getopt has complained about wrong arguments to stdout
    exit 1
fi
# read getopt’s output this way to handle the quoting right:
eval set -- "$PARSED"

# default options
input=""
outFile="parser"
outFolder="."
ctfFolder="../include"
parser="lscelr"
cxx="c++"

# now enjoy the options in order and nicely split until we see --
while true; do
    case "$1" in
        -h|--help)
            echo "
USAGE:

   ./parsergen [-o <filename>] [-f <folder>] [-c <folder>] [-p <lalr|canonical lr|lscelr>] [--cxx <compiler>] [--] <input>

Where:

   -o <filename>, --output <filename>
     The name of the saved parser file.
     The default value is \"parser\".

   -f <folder>, --folder <folder>
     The output folder. Temporary files will be created in this folder.
     The default value is \".\".

   -c <folder>, -ctf <folder>
     The location of the ctf.hpp header file.
     The default value is \"../include\" for use from ctf/tools.

   -p <lalr|canonical lr|lscelr>, --parser <lalr|canonical lr|lscelr>
     The used parser algorithm. The default value is \"lscelr\".

   -cxx <compiler>
     A C++17 compiler.
     The default value is \"c++\".

   <input>
     A path to a pair of .cpp and .h files generated by ctfgc.
     For source files \"x/foo.cpp\" and \"x/foo.h\", use the parameter \"x/foo\".


   parsergen: Generate the parser table from a pair of source files generated by ctfgc.
"
            exit 0
            ;;
        -o|--output)
            outFile="$2"
            shift 2
            ;;
        -f|--folder)
            outFolder="$2"
            shift 2
            ;;
        -c|--ctf)
            ctfFolder="$2"
            shift 2
            ;;
        --cxx)
            cxx="$2"
            shift 2
            ;;
        -p|--parser)
            parser="$2"
            case $parser in
                lscelr|lalr|canonical\ lr)
                    ;;
                *)
                    echo "Parser must be one of: \"lalr\", \"canonical lr\", \"lscelr\"."
                    exit 1
                    ;;
            esac
            shift 2
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Unknown argument."
            exit 1
            ;;
    esac
done

# handle non-option arguments
if [[ $# -ne 1 ]]; then
    echo "$0: The grammar C++ source name is required."
    exit 1
fi


input=$1
inputFile=`basename $input`

tempFolder=`mktemp -d 2>/dev/null || mktemp -d -t 'parsergentmp'`
echo "1/5: Copying source to \"$tempFolder\"."
# copy input files to folder
if ! mkdir -p $outFolder ||
   ! cp $input.h $tempFolder/$inputFile.h ||
   ! cp $input.cpp $tempFolder/$inputFile.cpp ; then
    echo "Could not write to the output folder."
    exit 2
fi
echo "2/5: Creating main()."
# append a short main() to the grammar .cpp file
tempCpp=$tempFolder/$inputFile.cpp;
echo "
#include <iostream>

int main() {
  ctf::Translation t(std::make_unique<ctf::LexicalAnalyzer>(), \"$parser\", $inputFile::grammar, std::make_unique<ctf::OutputGenerator>());
  t.save(std::cout);
  return 0;
}
" >> $tempCpp;

echo "3/5: Compiling source."
$cxx -std=c++17 -o $tempFolder/tmp.out -I $ctfFolder $tempCpp;
echo "4/5: Creating saved parser."
$tempFolder/tmp.out >| $outFolder/$outFile;
echo "5/5: Cleaning up."
rm -r $tempFolder;

exit 0
