#!/bin/bash
set -o errexit -o pipefail -o noclobber -o nounset

! getopt --test > /dev/null 
if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
    echo 'I’m sorry, `getopt --test` failed in this environment.'
    exit 999
fi

OPTIONS=o:f:p:c:h
LONGOPTS=output:,folder:,parser:,ctf:,help,cxx:

# -use ! and PIPESTATUS to get exit code with errexit set
# -temporarily store output to be able to check for errors
# -activate quoting/enhanced mode (e.g. by writing out “--options”)
# -pass arguments only via   -- "$@"   to separate them correctly
! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name "$0" -- "$@")
if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    # e.g. return value is 1
    #  then getopt has complained about wrong arguments to stdout
    exit 1
fi
# read getopt’s output this way to handle the quoting right:
eval set -- "$PARSED"

# default options
input=""
outFile="parser"
outFolder="."
ctfFolder="../include"
parser="lscelr"
cxx="c++"

# now enjoy the options in order and nicely split until we see --
while true; do
    case "$1" in
        -h|--help)
            echo "usage:
./parsergen [-o outputFile] [-f outputFolder] [-c ctfIncludeLocation] [-p lalr|canonical lr|lscelr] [--cxx compiler] inputGrammarFiles

options:
  -o|--output outputFile - The name of the saved parser file. Default is \"parser\".

  -f|--folder outputFolder - The output folder. Temporary files will be created in this folder.
                             Default is \".\".

  -c|-ctf ctfIncludeLocation - The location of the ctf.hpp header file.
                               Default is \"../include\" for use from ctf/tools.

  -p|--parser lalr|canonical lr|lscelr - The used parser algorithm. Default is \"lscelr\".

  -cxx compiler - A C++17-capable compiler. Default is \"c++\".

  inputGrammarFiles - for source files foo.cpp and foo.h generated by ctfgc, enter \"foo\".
"
            exit 0
            ;;
        -o|--output)
            outFile="$2"
            shift 2
            ;;
        -f|--folder)
            outFolder="$2"
            shift 2
            ;;
        -c|--ctf)
            ctfFolder="$2"
            shift 2
            ;;
        --cxx)
            cxx="$2"
            shift 2
            ;;
        -p|--parser)
            parser="$2"
            case $parser in
                lscelr|lalr|canonical\ lr)
                    ;;
                *)
                    echo "Parser must be one of: \"lalr\", \"canonical lr\", \"lscelr\"."
                    exit 1
                    ;;
            esac
            shift 2
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Unknown argument."
            exit 1
            ;;
    esac
done

# handle non-option arguments
if [[ $# -ne 1 ]]; then
    echo "$0: The grammar C++ source name is required."
    exit 1
fi

input=$1
inputFile=`basename $input`
# echo "input: $input, folder: $outFolder, parser: $parser, out: $outFile"
echo "1/5: Copying source to \"$outFolder\"."
# copy input files to folder
if ! mkdir -p $outFolder || ! cp $input.h $outFolder/$inputFile.h || ! cp $input.cpp $outFolder/$inputFile.cpp ; then
    echo "Could not write to the output folder."
    exit 2
fi
echo "2/5: Creating main()."
# append a short main() to the grammar .cpp file
tempCpp=$outFolder/$inputFile.cpp;
echo "
#include <iostream>

int main() {
  ctf::Translation t(std::make_unique<ctf::LexicalAnalyzer>(), \"$parser\", $inputFile::grammar, std::make_unique<ctf::OutputGenerator>());
  t.save(std::cout);
  return 0;
}
" >> $tempCpp;

echo "3/5: Compiling source."
$cxx -std=c++17 -o $outFolder/tmp.out -I $ctfFolder $tempCpp;
echo "4/5: Creating saved parser."
$outFolder/tmp.out >| $outFolder/$outFile;
echo "5/5: Cleaning up."
rm $outFolder/tmp.out $outFolder/$inputFile.h $outFolder/$inputFile.cpp;

exit 0
